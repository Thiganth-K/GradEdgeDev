const crypto = require('crypto');

// Detect if a stored password looks like a Werkzeug pbkdf2 hash
// Example: "pbkdf2:sha256:260000$<salt>$<hash>"
function isWerkzeugHash(hash) {
	return (
		typeof hash === 'string' &&
		hash.includes('$') &&
		hash.startsWith('pbkdf2:')
	);
}

// Verify a Werkzeug-style pbkdf2 hash generated by Python's
// werkzeug.security.generate_password_hash
async function verifyWerkzeugPassword(password, stored) {
	if (!isWerkzeugHash(stored)) return false;
	const parts = stored.split('$');
	if (parts.length !== 3) return false;
	const method = parts[0];
	const salt = parts[1];
	const hashVal = parts[2];

	const methodParts = method.split(':');
	if (methodParts[0] !== 'pbkdf2') return false;
	const digest = methodParts[1] || 'sha256';
	const iterations = parseInt(methodParts[2] || '260000', 10);
	if (!Number.isFinite(iterations) || iterations <= 0) return false;

	// Werkzeug stores the derived key base64-encoded
	const hashBuf = Buffer.from(hashVal, 'base64');
	const keyLen = hashBuf.length || 32;

	const derived = await new Promise((resolve, reject) => {
		crypto.pbkdf2(
			password,
			salt,
			iterations,
			keyLen,
			digest,
			(err, key) => {
				if (err) return reject(err);
				return resolve(key);
			},
		);
	});

	const derivedB64 = derived.toString('base64');
	// Use timing-safe comparison
	return (
		derivedB64.length === hashVal.length &&
		crypto.timingSafeEqual(Buffer.from(derivedB64), Buffer.from(hashVal))
	);
}

// Generate a Werkzeug-compatible pbkdf2 hash string so that
// Python and Node can both verify it.
async function generateWerkzeugHash(password, options = {}) {
	const iterations = options.iterations || 260000;
	const digest = options.digest || 'sha256';
	const saltBytes = options.saltBytes || 16;
	const salt = crypto.randomBytes(saltBytes).toString('hex');
	const keyLen = options.keyLen || 32;

	const derived = await new Promise((resolve, reject) => {
		crypto.pbkdf2(
			password,
			salt,
			iterations,
			keyLen,
			digest,
			(err, key) => {
				if (err) return reject(err);
				return resolve(key);
			},
		);
	});

	const hashVal = derived.toString('base64');
	const method = `pbkdf2:${digest}:${iterations}`;
	return `${method}$${salt}$${hashVal}`;
}

// High-level helpers used by controllers/auth
async function hashPassword(password) {
	if (!password) throw new Error('password required');
	return generateWerkzeugHash(password);
}

async function verifyPassword(password, stored) {
	if (!stored) return false;
	// 1) Werkzeug-style hash (Python or new Node accounts)
	if (isWerkzeugHash(stored)) {
		return verifyWerkzeugPassword(password, stored);
	}
	// 2) Plain-text fallback for old Node accounts created
	// before hashing was introduced
	return stored === password;
}

module.exports = {
	isWerkzeugHash,
	verifyWerkzeugPassword,
	generateWerkzeugHash,
	hashPassword,
	verifyPassword,
};
